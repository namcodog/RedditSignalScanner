# Reddit Signal Scanner - 本地环境验收清单

**验收目标**: 确保后端（8006）和前端（3006）正常运行并可以完成完整的分析流程

---

## 🚀 启动服务

### 方式一：使用启动脚本（推荐）

```bash
# 在项目根目录执行
./scripts/start-local.sh
```

### 方式二：使用 Makefile

```bash
# 在项目根目录执行
make dev-golden-path
```

---

## ✅ 验收步骤

### 第一步：验证服务启动

#### 1.1 检查后端服务（端口 8006）

**在浏览器中访问**:
- [ ] http://localhost:8006/ 
  - **期望结果**: 返回 JSON `{"message": "Reddit Signal Scanner API"}`
  
- [ ] http://localhost:8006/docs
  - **期望结果**: 显示 FastAPI Swagger 文档页面
  - **检查点**: 页面标题为 "FastAPI"，可以看到所有 API 端点

**在终端中验证**:
```bash
# 测试后端健康检查
curl http://localhost:8006/

# 期望输出: {"message":"Reddit Signal Scanner API"}
```

#### 1.2 检查前端服务（端口 3006）

**在浏览器中访问**:
- [ ] http://localhost:3006/
  - **期望结果**: 显示 Reddit Signal Scanner 首页
  - **检查点**: 
    - 页面标题包含 "Reddit Signal Scanner"
    - 有产品描述输入框
    - 有提交按钮

**在终端中验证**:
```bash
# 测试前端服务
curl -I http://localhost:3006/

# 期望输出: HTTP/1.1 200 OK
```

#### 1.3 检查 Redis 服务

```bash
# 测试 Redis 连接
redis-cli ping

# 期望输出: PONG
```

#### 1.4 检查 PostgreSQL 服务

```bash
# 测试 PostgreSQL 连接
pg_isready

# 期望输出: /tmp:5432 - accepting connections
```

#### 1.5 检查 Celery Worker

```bash
# 查看 Celery Worker 日志
tail -20 /tmp/celery_worker.log

# 期望输出包含: "celery@xxx ready"
```

---

### 第二步：验证 API 端点

#### 2.1 测试创建任务 API

**在浏览器中**:
1. 访问 http://localhost:8006/docs
2. 找到 `POST /api/tasks/` 端点
3. 点击 "Try it out"
4. 输入请求体（示例）:
```json
{
  "product_description": "智能手表，支持心率监测和GPS定位",
  "user_email": "test@example.com"
}
```
5. 点击 "Execute"

**期望结果**:
- [ ] 返回状态码 200
- [ ] 响应包含 `task_id`
- [ ] 响应包含 `status: "pending"`

**在终端中**:
```bash
# 使用 curl 测试
curl -X POST "http://localhost:8006/api/tasks/" \
  -H "Content-Type: application/json" \
  -d '{
    "product_description": "智能手表，支持心率监测和GPS定位",
    "user_email": "test@example.com"
  }'

# 期望输出包含: "task_id", "status": "pending"
```

#### 2.2 测试获取任务状态 API

**使用上一步获得的 task_id**:

```bash
# 替换 {task_id} 为实际的任务 ID
curl http://localhost:8006/api/tasks/{task_id}

# 期望输出包含: "task_id", "status", "progress"
```

#### 2.3 测试 SSE 实时进度

**在浏览器中**:
```bash
# 替换 {task_id} 为实际的任务 ID
# 在浏览器中访问（会持续显示进度）
http://localhost:8006/api/tasks/{task_id}/stream
```

**期望结果**:
- [ ] 浏览器显示实时进度事件
- [ ] 事件格式为 `data: {...}`
- [ ] 包含 `progress` 字段

---

### 第三步：端到端流程验收

#### 3.1 提交分析任务

1. **打开前端首页**: http://localhost:3006/
2. **输入产品描述**（示例）:
   ```
   智能手表，支持心率监测、GPS定位、睡眠追踪和运动模式
   ```
3. **点击提交按钮**

**期望结果**:
- [ ] 页面跳转到等待页面
- [ ] URL 包含任务 ID（例如: `/waiting?taskId=xxx`）

#### 3.2 查看实时进度

**在等待页面**:
- [ ] 显示进度条或进度百分比
- [ ] 显示当前状态（例如: "正在分析..."）
- [ ] 进度实时更新（通过 SSE）

**期望进度事件**:
1. "任务已创建"
2. "正在分析产品描述..."
3. "正在搜索相关社区..."
4. "正在生成报告..."
5. "分析完成"

#### 3.3 查看分析报告

**分析完成后**:
- [ ] 页面自动跳转到报告页面
- [ ] URL 包含任务 ID（例如: `/report?taskId=xxx`）

**报告页面应包含**:
- [ ] 产品描述
- [ ] 推荐的 Reddit 社区列表
- [ ] 每个社区的相关性评分
- [ ] 每个社区的订阅人数
- [ ] 每个社区的描述

---

### 第四步：数据验证

#### 4.1 检查数据库中的任务记录

```bash
# 连接到数据库
psql -d reddit_scanner

# 查询任务表
SELECT id, status, product_description, created_at 
FROM tasks 
ORDER BY created_at DESC 
LIMIT 5;

# 期望结果: 显示最近创建的任务
```

#### 4.2 检查 Redis 缓存

```bash
# 查看 Redis 中的键
redis-cli KEYS "*"

# 查看任务状态缓存
redis-cli GET "task:status:{task_id}"

# 期望结果: 返回任务状态 JSON
```

---

### 第五步：性能验证

#### 5.1 测试并发任务

**创建多个任务**:
```bash
# 创建 3 个并发任务
for i in {1..3}; do
  curl -X POST "http://localhost:8006/api/tasks/" \
    -H "Content-Type: application/json" \
    -d "{
      \"product_description\": \"测试产品 $i\",
      \"user_email\": \"test$i@example.com\"
    }" &
done
wait

# 期望结果: 所有任务都成功创建
```

#### 5.2 检查 Celery Worker 处理

```bash
# 查看 Celery Worker 日志
tail -f /tmp/celery_worker.log

# 期望结果: 
# - 显示任务被接收
# - 显示任务处理进度
# - 显示任务完成
```

---

### 第六步：错误处理验证

#### 6.1 测试无效输入

**在 API 文档中测试**:
1. 访问 http://localhost:8006/docs
2. 测试 `POST /api/tasks/` 端点
3. 输入空的产品描述:
```json
{
  "product_description": "",
  "user_email": "test@example.com"
}
```

**期望结果**:
- [ ] 返回状态码 422（Validation Error）
- [ ] 错误信息明确指出问题

#### 6.2 测试不存在的任务

```bash
# 查询不存在的任务 ID
curl http://localhost:8006/api/tasks/00000000-0000-0000-0000-000000000000

# 期望结果: 返回 404 Not Found
```

---

## 📊 验收通过标准

### 必须通过的检查项（核心功能）

- [ ] 后端服务正常启动（端口 8006）
- [ ] 前端服务正常启动（端口 3006）
- [ ] Redis 服务正常运行
- [ ] PostgreSQL 服务正常运行
- [ ] Celery Worker 正常运行
- [ ] 可以通过前端提交分析任务
- [ ] 可以查看实时进度
- [ ] 可以查看分析报告
- [ ] 任务状态正确保存到数据库
- [ ] API 文档可以正常访问

### 建议通过的检查项（增强功能）

- [ ] 并发任务处理正常
- [ ] 错误处理符合预期
- [ ] Redis 缓存正常工作
- [ ] SSE 实时推送正常
- [ ] 数据库迁移正常

---

## 🛑 停止服务

### 使用停止脚本

```bash
./scripts/stop-local.sh
```

### 使用 Makefile

```bash
make kill-ports && make kill-celery && make kill-redis
```

---

## ❌ 常见问题

### 问题 1: 后端启动失败

**检查步骤**:
```bash
# 查看后端日志
tail -f /tmp/backend_uvicorn.log

# 检查端口是否被占用
lsof -i:8006

# 检查 Python 版本
/opt/homebrew/bin/python3.11 --version
```

### 问题 2: 前端启动失败

**检查步骤**:
```bash
# 查看前端日志
tail -f /tmp/frontend_vite.log

# 检查端口是否被占用
lsof -i:3006

# 检查依赖是否安装
cd frontend && npm list
```

### 问题 3: Celery Worker 无法连接 Redis

**检查步骤**:
```bash
# 检查 Redis 是否运行
redis-cli ping

# 查看 Celery 日志
tail -f /tmp/celery_worker.log

# 检查 backend/.env 配置
cat backend/.env | grep REDIS
```

### 问题 4: 数据库连接失败

**检查步骤**:
```bash
# 检查 PostgreSQL 是否运行
pg_isready

# 检查数据库是否存在
psql -l | grep reddit_scanner

# 检查 backend/.env 配置
cat backend/.env | grep DATABASE_URL
```

---

## 📝 验收报告模板

```markdown
# 本地环境验收报告

**验收时间**: YYYY-MM-DD HH:MM
**验收人**: [你的名字]

## 环境信息
- Python 版本: [版本号]
- Node.js 版本: [版本号]
- PostgreSQL 版本: [版本号]
- Redis 版本: [版本号]

## 验收结果

### 服务启动
- [ ] 后端服务 (8006): ✅ / ❌
- [ ] 前端服务 (3006): ✅ / ❌
- [ ] Redis: ✅ / ❌
- [ ] PostgreSQL: ✅ / ❌
- [ ] Celery Worker: ✅ / ❌

### API 端点
- [ ] POST /api/tasks/: ✅ / ❌
- [ ] GET /api/tasks/{task_id}: ✅ / ❌
- [ ] GET /api/tasks/{task_id}/stream: ✅ / ❌
- [ ] GET /api/tasks/{task_id}/report: ✅ / ❌

### 端到端流程
- [ ] 提交任务: ✅ / ❌
- [ ] 查看进度: ✅ / ❌
- [ ] 查看报告: ✅ / ❌

### 数据验证
- [ ] 数据库记录: ✅ / ❌
- [ ] Redis 缓存: ✅ / ❌

## 问题记录
[记录遇到的问题和解决方案]

## 总体评价
- [ ] 通过验收
- [ ] 需要修复后重新验收

## 备注
[其他需要说明的内容]
```

---

**准备好了吗？现在就运行 `./scripts/start-local.sh` 开始验收吧！** 🚀

